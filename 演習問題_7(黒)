// 【３】
public class SuperClass {
  private int num;
  public void setNum(int num) {
    this.num = num;
  }
}

public class SubClass extends SuperClass {
  private int num;
  public int getNum() {
    this.num = num;
  }
}

public class SubClass extends SuperClass {
  private int num;
  public int getNum() {
    return this.num;
  }
}

public class Main {
  public static void main(String[] args) {
    SubClass sub = new SubClass();
    sub.setNum(10);
    System.out.println(sub.getNum());
  }
}
/*
・ SubClassの2行目でコンパイルエラーが発生する
・ Mainクラスの4行目の実行中に例外がスローされる
・ 0が表示される  // 〇
・ 10が表示される

継承に関する問題
スーパークラスの定義の上にサブクラスとしての差分を載せたものが、サブクラスのインスタンス
しかし、サブクラスの中にスーパークラスの定義が含まれているわけではない
setで10を引数に入れていてもSubClassが見に行くgetはSupeClassのnumフィールド
 */

// 【５】
public class A {
  public A() {
    System.out.println("A");
  }
}

public class B extends A {
  public B() {
    System.out.println("B");
  }
}

pubic class Main {
  public static void main(String[] args) {
    B b = new B();
  }
}
/*
・ 「A」と表示される
・ 「A」と表示される
・ 「A」「B」と表示される   // 〇
・ 「B」「A」と表示される

継承をした時のコンストラクタの実行準に関する問題
コンストラクタは、スーパークラスのインスタンスと差分のインスタンスの両方がそれぞれを
準備するために持っている
コンストラクタは、そのコンストラクタが定義されているクラスのインスタンスを
準備するためのメソッドであることを忘れてはいけない
その為、サブクラスのインスタンスを作ったときには、必ず両方小野コンストラクタが実行される
実行のコンストラクタの呼び出しと実行は、次の順番
1. サブクラスのコンストラクタ呼び出し
2. スーパークラスのコンストラクタ呼び出し
3. スーパークラスのコンストラクタの実行
4. サブクラスのコンストラクタの実行

この実行順を実現するために、コンパイル時にサブクラスのコンストラクタの1行目には、
次のようなスーパークラスのコンストラクタ呼び出しが追加される
pbulic class B extends A {
    public B()  {
      super();    // コンパイル時に追加
      System.out.println("B")
    }
  }

なお、このようにサブクラスのコンストラクタからスーパークラスのコンストラクタを呼び出しながら
各インスタンスを準備する仕組みを「コンストラクタチェーン」と呼ぶ

サブクラスのコンパイル時には、サブクラスのコンストラクタの1行目に「super();」が追加される
*/

// 【６】
public class SuperClass {
  public SuperClass(String val) {
    System.out.println(val);
  }
}

public class SubClass extends SuperClass {
  // public SubClass() {      // コンパイル時によって追加されたデフォルトコンストラクタ
  //   super();
  // }
  public void test() {
    System.out.println("test");
  }
}

public class Sample {
  public static void main(String[] args) {
    SubClass sub = new SubClass();
    sub.test();
  }
}
/*
・ コンパイルエラーが発生する   // 〇
・ 実行時に例外がスローされる
・ 「nulltest」と表示される
・ 「test」と表示される

デフォルトコンストラクタとコンストラクタチェーンについての問題
サブクラスのコンストラクタでは、スーパークラスのコンストラクタを呼び出す
之を「コンストラクタチェーン」と呼ぶが、この仕組みは、コンパイラによって
自動的に追加されるデフォルトコンストラクタでも同様
デフォルトコンストラクタはコンストラクタチェーンを実現するために、スーパークラスの
コンストラクタを呼び出す
この時に呼び出されるのは、「引数なしスーパークラスのコンストラクタ」

しかし、設問のSubClassクラスのスーパークラスであるSuperClassクラスには、
引数なしのコンストラクタはない
しかも、引数ありのコンストラクタを明示的に定義的に定義しているため、
デフォルトコンストラクタは追加されない
 */

// 【７】
public class SuperClass {
  public SuperClass() {
    System.out.println("A");
  }
  public SuperClass(String val) {
    System.out.println(val);
  }
}

public class SubClass extends SuperClass {
  public Subclass extends Superclass() {
    // insert code here
  }
}

public class Main {
  public static void main(String[] args) {
    new SubClass();
  }
}
/*
実行結果
A
B


・ SubClass("B");
・ this("B");   // 〇
・ super("B");
・ SuperClass("B");

コンストラクタチェーンの定義に関する問題
コンストラクタは、インスタンスの準備をするためのメソッド
そのため、コンストラクタも通常のメソッドと同様にオーバーロードできる
設問のSuperClassクラス、SubClassクラスともにコンストラクタをオーバーロードし、
2つずつ定義している
通常のメソッドが、ほかのメソッドを呼び出せるのと同様に、コンストラクタもほかの
コンストラクタを呼び出せる
同じクラスに定義している別のコンストラクタを呼び出すには、this()を使う

SubClassクラスのインスタンス化の流れをまとめ
1. SabClassクラスの引数なしのコンストラクタ呼び出し
2. SabClassクラスの引数ありのコンストラクタ呼び出し
3. SuperClassクラスの引数なしのコンストラクタ呼び出し
4. SuperClassクラスの引数なしのコンストラクタを実行し、コンソールにAが表示される
5. SabClassクラスの引数ありのコンストラクタを実行し、コンソールにBが表示される
同じクラスのコンストラクタはthis()、スーパークラスのコンストラクタはsuper()で呼び出す
this()とsuper()を同一コンストラクタ内に記述するとコンパイルエラーになる
また、スーパークラスのコンストラクタ呼び出しはコンストラクタ内で1回しかできない
*/

// 【９】
/*
サブクラスでスーパークラスのメソッドを再定義することを何と呼ぶ？正しいものを1つ選択
・ カプセル化   //  関係するデータとそのデータを必要とするメソッドを1つのクラスとしてまとめること
・ ポリモーフィズム // 抽象化を実現したもの。オーバーライドによって実現されるが、メソッドの再定義そのものではない
・ オーバーロード // 同じ名前で引数の種類や数、順番が異なるメソッドを複数定義すること
・ オーバーライド // 〇

オーバーライドに関する問題
オーバーライドとは、スーパークラスに定義したメソッドをサブクラスで「再定義」すること
「多重定義」を表すオーバーロードと間違えやすいので注意すること！

オーバーライドは、メソッドの定義を上書きするわけではない
スーパークラスの定義に加えて、サブクラスに新しい定義を追加すること
そのため、サブクラスのインスタンスには、オーバーライドされたメソッドと、オーバーライドした
メソッドの両方が含まれることになる。

オーバーライドは、スーパークラスに定義したメソッドをサブクラスで「再定義」すること
オーバーロードとの違いを押さえておくこと！
*/

// 【１３】
/*
インタフェースに定義するフィールドの修飾子として正しいもの3つ選択
・ protected
・ static // 〇
・ final  // 〇
・ abstract
・ public // 〇
・ native
・ synchronized

インタフェースに定義する定数フィールドに関する問題
インタフェースは条坊隠蔽を実現する方法として使用
情報隠蔽は、抽象化を維持する目的で、ソフトウェアのモジュールのうち、公開する
部分と非公開にする部分を明確に分け、非公開にする部分を隠蔽(アクセス制限)する
インタフェースは、公開する部分を担う
公開する部分は型の情報
型はモジュールの扱い方を阿波らしており、実際に動作するインスタンスをどのように扱いたいのかを
指定するために使う。インタフェースは、この「型」だけを表現したもの

インタフェースは型を定義するものであるため、インスタンス化できない
インタフェースはインタフェースを持てない
インタフェースに定義できるのは、定数フィールドのみ
定数フィールドとは、statilcとfinalで修飾されたフィールドの事で、staticであるため
インスタンスを必要としない。そのため、型情報しか持たないインタフェースにも定義できる
なお、インタフェースに定義するフィールドは、コンパイラによって暗黙的に
public、static、finalで修飾される
publicで修飾されるのは、インタフェースは前述とおり「公開するためのもの」であるから
*/

// 【１４】
/*
インタフェースに定義するメソッドの修飾子として、正しもの2つ選択
・ protected
・ final
・ abstract  // 〇
・ public   // 〇
・ native
・ synchronized

インタフェースに定義する抽象メソッドに関する問題
インタフェースは本来、型を定義するもので、実装は含まれていない
インタフェースに定義できるのは、定数フィールドと抽象メソッドの2つ
定数フィールドはstatic、finalなフィールドで、インスタンスを作る必要がなく、かつ値を
変更できないフィールド
抽象メソッドは、メソッドの宣言だけで、具体的な処理内容を持たない

メソッドの宣言は、必ずセミコロン「；」で終わらなければならない
メソッドの宣言で中カッコ「｛ ｝」を記述すると、抽象メソッドではなく、具体的な処理を持つ
具象メソッドとしてコンパイラに解釈される

情報隠蔽のうち公開部分をインタフェースとして定めるため、そのメソッドはpublicでなければならない
また、具体的な処理を持たないメソッドは、具体的な処理を持つメソッドと区別するためにも
abstractで修飾しなければいけない。そのため、インタフェースに定義した抽象メソッドは、コンパイラによって
暗黙的にpublic、abstractで修飾する
 */

// 【１５】
/*
インタフェースの特徴として、正しいもの3つ選択
・ クラスは1つだけインタフェースを実現できる
・ インターフェースは、ほかのインタフェースを継承できる   // 〇
・ インターフェースは、単一継承のみ可能である
・ クラスはインターフェースを多重実現できる   // 〇
・ インターフェースは、抽象メソッドが定義できる   // 〇
・ インターフェースは、具象メソッドが定義できる

インタフェースの特徴に関する問題
クラスが実現すべきメソッドの一覧を定めたもの
クラスの使用や規約、ルールに相当するもので、具体的な処理内容については定義しない
そのため、インタフェースには具象メソッドは定義できない
インタフェースに定義できるのは、メソッド宣言だけの抽象メソッド

インタフェースに規定している抽象メソッドの具体的な処理は、それを実現したクラスに記述する。
インタフェースを実現するには、クラスの宣言時にimplementsを使用する
クラスは、一度に複数のインタフェースを実現できる
複数のインタフェースを実現するには、implementsの後ろにインタフェースの名前をカン区切りで列挙する
インタフェースは、既存のインタフェースを継承して定義できる
インタフェースの継承は、クラスの継承と同様にextendsキーワードを使って宣言する
インタフェース間の継承は、あるルールを引き継いだ(拡張した)新しいルールを規定することに相当する
複数のインタフェースを一度に継承できる
複数のものを一度に継承することを「多重継承」と呼ぶ
多重継承は、インタフェースを継承するときだけ認められており、クラスの継承では認められていないことに注意

implementsは、インタフェースを実現するクラスを宣言するときに使う
クラスとインタフェースの実現・継承に関して、以下の点を押さえておくこと
クラスとインタフェースで多重継承のルールが異なる点は特に重要
・ クラスは複数のインタフェースを実現できる
・ インタフェースは複数のインタフェースを継承できる
・ クラスは複数のクラスを継承できない
 */

// 【１６】
/*
抽象クラスに関する説明として、正しいものを2つ選択
・ 全てのメソッドは実装済みでなければならない
・ 抽象メソッドを持つことができる   // 〇
・ 実現しているインタフェースのメソッドを実装する必要はない   // 〇
・ インスタンスを生成できる
・ 抽象メソッドは、暗黙的にabstractで修飾される

抽象クラスに関する問題
クラスとインタフェース両方の性質をもったクラス
抽象クラスと区別するために、普通のクラスの事を「具象クラス」と呼ぶ
また、インタフェースに定義するメソッドを「抽象メソッド」と呼ぶのに対して、
具象クラスに定義するメソッドを「具象メソッド」と呼ぶ。抽象メソッドと具象メソッドの違いは、
具体的な処理内容を持つかどうか
クラスとインタフェース両方の性質を持った抽象クラスは、どちらのメソッドも定義できる

インタフェースには抽象メソッドしか記述できないため、コンパイラによって自動的に修飾子が追加される
しかし、抽象クラスには具象メソッドと抽象メソッドの両方を記述できるため、コンパイラは修飾子を追加できない
そのため、抽象クラスに定義する抽象メソッドは、プログラマーが明示的にabstractで
修飾しなければコンパイルエラーになる

抽象クラスの特徴を押さえておく
・ 抽象クラスは、クラスとインタフェース諜報の性質を持つクラス
・ 抽象クラスはインスタンス化できない
・ 抽象クラスに定義したメソッドは、抽象クラスを継承する具象クラスが実装する
・ 抽象クラスに定義するメソッドは、abstractで修飾しないとコンパイルエラーになる
 */

// 【１８】
/*
パッケージに関する説明として、正しいものを3つ選択
・ 名前空間を提供する   // 〇
・ パッケージ名にはドメイン名を逆にしたものを使用しなければならない
・ アクセス制御を提供する   // 〇
・ クラスの分類を可能にする // 〇
・ パッケージ宣言はソースファイルの1行目に記述する

パッケージに関する問題
パッケージとは次の3つの機能を提供するもの
・ 名前空間を提供し、名前の衝突を避ける
・ アクセス修飾子と組み合わせてアクセス制御機能を提供する
・ クラスの分類を可能にする

大規模なソフトウェアが複数存在するエンタープライズシステムでは、数えきれないほどのクラスが存在する
この時、単純なクラス名だけでは、ほかのシステムのクラスと名前が衝突してしまう
このような事態を避けるために、コンパイラやJVMは、クラスを「パッケージ名＋クラス名」の
完全修飾クラス名で扱う
パッケージ名はできるだけ一意なものが推奨される
そこで、習慣としてパッケージ名にはドメイン名を逆にしたものが利用される
例えば、xxx.co.jpであれば、jp.co.xxxという具合
ドメイン名以外のものも使用できる
情報隠蔽の実現にはパッケージが欠かせない。パッケージがあるおかげで、公開するものと非公開にするものを
明確に分け、アクセス制御が可能になる
パッケージとディレクトリ構造がマッピングされると、数多くのクラスを分類整理することができ、
ソフトウェアの管理が容易になる
パッケージ宣言は、ソースファイルの先頭行で宣言しなければならない
パッケージ宣言よりも前に記述できるのはコメントだけ
構文）
package パッケージ名;

パッケージ宣言をしなかったクラスは無名パッケージに所属しているとみなされる
無名パッケージは学習用に用意されたんのであり、実際の開発では推奨されない
 */

// 【１９】
/*
インポート宣言に関する説明として、正しいものを2つ選択
・ java.langパッケージに所属するクラスは、インポート宣言を省略できる  // 〇
・ 同じパッケージに所属するクラスは、インポート宣言を省略できる  // 〇
・ 異なるパッケージに所属するクラスを利用する場合には、必ずインポート宣言をしなければならない
・ インポート宣言は、ソースファイルの先頭行から列挙しなければならない
・ インポート宣言では、利用したいクラスが所属するパッケージ名までを指定する

パッケージのインポートに関する問題
本来は完全修飾クラス名で記述しなければならないものを、省略表記できるようにするのが、
インポート宣言。なお、ソースコードを完全修飾クラス名で記述するのであれば、インポート宣言は必要ない
構文）
import インポートするクラスの完全修飾クラス名;

java.langパッケージに所属するクラスは、インポート宣言する必要はない
java.langパッケージは基本低なクラスがまとめられたパッケージであり、このパッケージに所属する
クラスは頻繁に利用するため、省略することができる。また、同じパッケージに属するクラスも省略可能

インポート宣言は、パッケージ宣言の後ろ、クラス宣言の前に行う
パッケージ宣言が先頭であることを忘れないようにする

例） パッケージ宣言とインポート宣言をした場合(4行目以降は省略)
package ex3;

import java.math.BigDecimal;

インポート宣言は、省略表記したいクラスの完全修飾クラス名を記述する
クラス名の部分は、アスタリスク「*」を使って「java.util.*」のようにワイルドカード表記が可能で、
パッケージ名を省略することもできる
 */