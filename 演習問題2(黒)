// 【２】
/*
参照型として正しいもの3つ選択
・ String // 〇
・ Data // 〇
・ int
・ boolean
・ char[] // 〇

データ型にはプリミティブ型(基本)と参照型がある
参照型は、さらにオブジェクト型と配列型、列挙型に分類される
 */

// 【４】
/*
真偽値を保持できる型として正しいもの1つ選択
・ char
・ boolean  // 〇
・ double
・ int
・ String

真偽値を扱うデータ型に関する問題
真偽値を保持できる方は、boolean
真偽値とは、ある条件に合致しているか(真)、合致していないか(偽)の結果を表し、
それぞれtrueかfalseのリテラルで表現する
 */

// 【６】
/*
変数の宣言として正しいもの2つ選択
・ int number;   // 〇
・ length long;
・ String name, code;   // 〇
・ boolean long;
・ douled 3.7;

変数の宣言方法に関する問題
≪構文≫
アクセス修飾子 型名 変数名；

アクセス修飾子にはpublic protected dprivate がある
このアクセス修飾子は、省略も可能。省略した場合はアクセス修飾子
「なし」が適用される

「変数名」は、複数の変数を識別するため、メソッド内で一意でなくてはいけない
また、あらかじめ定義されているキーワード（予約語）を変数名として利用することができない
なお、同じ型であれば次のようにカンマ区切りで複数の変数を一度に宣言することも可能
例）
int number, length; // 2つのint型変数numberとlength
 */

// 【８】
/*
真偽値を扱う変数の宣言と初期化方法として正しいもの
・ boolean flag = TRUE;
・ boolean flag = "true";
・ boolean flag = false;  // 〇
・ boolean flag = 0;
・ boolean flag = 'false';

真偽値リテラルのtrueとfalseについて、次の2点を抑えておく
・ 大文字と小文字が区別される(TRUEとFALSEは、真偽値リテラルとはみなされない)
・ シングルクォーテーションやダブルクォーテーションで囲むと、真偽値リテラルとみなされない
 */

// 【９】
/*
文字を扱う変数の宣言と初期化方法として正しいもの3つ選択
・ char c = 'AB';
・ char c = "T";
・ char c = '\u1F1C'; // 〇
・ char c = 'U';  // 〇
・ char c = 97; // 〇

文字データの指定方法に関する問題
char型変数では文字を扱う
文字とは、1文字分のデータを表す
文字の値を指定する方法には、シングルクォーテーション「'」で1文字を囲む方法と
Unicodeで指定する方法の2種類がある

Java言語では、文字の正の整数(0~65535)に割り振って管理している
整数の97をchar型変数に代入している。97という文字コードには「a」が割り振られている
char型で扱う「文字」とは、1文字分のデータ
値を指定する方法には以下の2通りがある
・シングルクォーテーション「'」で1文字で囲む
・Unicodeでしていする
 */

// 【１１】
/*
定数の宣言方法として正しいもの2つ選択
・ int final a = 10;
・ int frozen a = 17;
・ frozen itn a = 13;
・ final int a = 8; // 〇
・ int a final = 3;
・ final int a; // 〇

定数の宣言方法に関する問題
≪構文≫
アクセス修飾子 final 定数の型 定数名；

定数は、一度値を代入すると、その値を変更できない
プログラム内で固定値を扱いたい場合や、値の代入を一回に制限したい場合、定数を利用する

 */

// 【１３】
public class Main {
  public static void main(String[] args) {
    char a = 'A'; b = 'B';
    System.out.print(a);
    System.out.print(b);
  }
}
/*
変数の宣言方法に関する問題
変数は、利用する前に宣言しなければならない
変数の宣言は、データ型と変数名のセットで行う
char a = 'A'; b = 'B';では、変数bに値を代入しようとしている
しかし、変数bを事前に宣言していない為、コンパイルエラーが発生する
次のように修正すれば、コンパイルできるようになる
例）
char a = 'A'; char b = 'B';
 */


// 【１５】
public class Item {
  // insert code here
}
/*
プログラムの2行目に挿入するコードとして正しいもの2つ選択
・ static int count;  // 〇
      アクセス修飾子を省略し、static変数を宣言している

・ int count static;
      staticキーワードが変数宣言の最後に記述されているので誤り

・ static private int count;    // 〇
      staticキーワードとアクセス修飾子の記述順は逆でも構わない

・ static count int;
      変数の型と変数名の記述順が逆になっているので誤り

static変数の宣言の構文に関する問題
static変数とは、クラスに属するフィールドの事で「クラス変数」や「staticフィールド」
とも呼ばれる。static変数はクラス単位で作られる変数で、インスタンス間で共有されることが特徴
static変数はインスタンスに作られる変数ではなく、static領域という場所に作られる変数

static変数は、複数のインスタンス官で共有されるため、あるインスタンスがstatic変数の
値を変更すると、別のインスタンスからは変更後の値を参照できるようになる
staticの宣言
≪構文≫
アクセス修飾子 static 型名 変数名；

「アクセス修飾子」とstaticキーワードの記述順は逆でも構わない
宣言する場所は、クラス定義の内側、メソッドの外側
例）
public class Item {
  public static int count;  // static変数countの宣言
  public int price;   // インスタンス変数priceの宣言
  public void test(){
    // any code
  }
}

static変数は、インスタンスに作られる変数ではなく、static魯唯機にクラス単位で
作られる変数。インスタンス間で共有されるため、あるインスタンスがstatic変数の値を
変更すると、別のインスタンスからは変更後の値を参照できる

static変数を宣言する場所は、クラス定義の内側、メソッドの外側
 */

// 【１６】
public class Main {
  public static void main(String[] args) {
    int a = 3;
    for(int i = 0; i < 3; i++) {
      int total = 0;
      total += a;
    }
    System.out.print(total);
  }
}

// 【１７】
/*
配列の宣言・生成方法として正しいもの1つ選択
・ int[] array = new int[];
      配列インスタンスを生成する為の要素数を指定していない

・ int() array = new int(3);
      角カッコ「[]」ではなく丸カッコ「()」を利用している

・ int array = new int[3];
      配列型変数の宣言に角カッコが記述されていない

・ int[3] array = new int[];
      配列型変数の宣言で各要素を指定している

・ int[] array = new int[3];  // 〇

配列に関する問題
配列型変数は参照型変数の一種
配列型変数は配列インスタンス(単に「配列」とも呼ぶ)への参照を保持する
配列インスタンスは、指定された戸数の要素を持ち、各要素にデータを保持できる
要素を指定するための添字は0から開始される。1からではないことに注意

配列は、プリミティブ型配列とオブジェクト型配列の2種類に分類される
プリミティブ型配列は、各要素に値を保持する
オブジェクト型配列は、各要素にインスタンスへの参照を保持する

≪構文≫
要素のデータ型[] 変数名；

配列型変数が値を保持するのではなく、配列インスタンスの各要素が値を保持する
値を保持するためには、配列型変数の宣言だけでなく、値を保持するための配列インスタンスの生成を
行わなければならない
配列インスタンスの生成は、newキーワードを用意手次のように記述
≪構文≫
変数名 = new 要素のデータ型[要素数]；


配列型変数の宣言と配列インスタンスの生成を1行で行う
≪構文≫
要素のデータ型[] 変数名 = new 要素のデータ型[要素数]；

配列インスタンス(配列)とは、「要素」と呼ばれるデータの集合
要素には0から始まる添字がつく
配列型変数は、配列への参照を保持するものである

配列型変数の宣言、配列インスタンスの生成の構文をしっかり覚えよう
 */

// 【１８】
/*
配列の初期化の記述として正しいもの1つ選択
・ int[] array = {3, 8, 10};    // 〇
      文法にのっとって、正しい

・ int[] array = new {3, 8, 10};
      要素の初期化にはnewキーワードは不要

・ int[] array = (3, 8, 10);
      初期化子を利用していない為誤り

・ int() array = {3, 8, 10};
      変数宣言に丸カッコ「()」を使用している

・ int array = {3, 8, 10};
      変数宣言に角カッコ「[]」が記述されていない。配列型変数の宣言ではない


配列とその要素の初期化に関する問題
配列インスタンスを生成した直後の要素は、デフォルト値で暗黙的に初期化される
宣言時に値を入力することを初期化という
プログラムに初期化の処理を明示的に記述できる。また、明示的に記述しない場合は、
ローカル変数以外は変数の型に応じてデフォルト値に初期化される
ローカル変数とは、メソッドブロック内で宣言した変数

 */

// 【２０】
public class Main {
  public static void main(String[] args) {
    int[] array = {3, 7, 5};
    System.out.println(array[1]);
  }
}
/*
配列の要素を参照する方法と添字の指定方法に関する問題
要素のデータを参照するには次のように記述する
≪構文≫
配列の変数名[添字]

実行結果：  7

 */

// 【２１】
public class Main {
  public static void main(String[] args) {
    int[] array = {1, 0, 2, 3};
    System.out.println(array[4]);
  }
}

/*
配列の添字に関する問題
配列の要素数以上の添字を指定すると、実行時に例外(ArraylndecOutOfBoundsException)が
発生する。存在しない4番目にアクセスすることになるため、実行時に例外が発生する
このように要素外にアクセスするコードを記述しても文法上は問題ないのでコンパイルエラーにはならない

設問のコードのint[] array = {1, 0, 2, 3};では、int型配列変数arrayの宣言と同時に、
1,0,2,3の値で初期化された配列インスタンスを生成している配列の添字は0から始まるため、
この場合は0～3となる
4行目では添字に4を指定して値をコンソールに出力しようとしているが、配列の要素数を超えたいるため
実行時に例外が発生する
したがって、実行時エラーになる
