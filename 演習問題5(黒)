// 【１】
/*
カプセル化の説明として正しいもの1つ選択
・ 同種の異なるインスタンスを同じ型で扱う // 抽象化の説明

・ 公開すべきものと非公開にすべきものを区別して扱う // 情報隠蔽の説明

・ 関係するものをひとまとめにする // 〇
      カプセル化は、関係するデータをまとめ、さらにそのデータを使う処理をまとめて
      1つのモジュールとして定義すること

・ クラスのフィールドを隠蔽し、ほかのクラスからは直接使えないようにする // データ隠蔽の説明

本設問で問われているカプセル化は、変更に強いソフトウェアを設計するための「設計原則」の一つ
正しくカプセル化されたモジュールは、変更に強く、開発の生産性向上だけでなく、
長期的に渡って行われる保守作業の軽減を実現する

設計とは、開発や運用を効率化し、コスト削減を実現するための作業を指している
その良し悪しは、どれだけコストが削減できたかで測ることができる
オブジェクト指向は、ソフトウェアの変更容易性や再利用性を向上させることで、
コスト削減効果を追求する設計技法

ソフトウェアを設計するにあたって、考えるべきことを要約すると
・どのような流れで処理をするのか？
      「処理の流れ」から設計を始めるのが構造化設計手法

・どのようなデータを扱うのか？
      「扱うデータ」から設計を始めるのがオブジェクト指向設計手法の特徴

「変更に強い設計」とは、次の2つの条件を満たすもの
・変更発生時にその影響範囲がすぐに特定できること
・変更への対応が工数をかけずにできること

カプセル化は、影響範囲の特定にかかわる重要な設計原則
カプセル化は、関係するデータをまとめ、さらにそのデータを使う処理をまとめて、1つの
モジュールとして定義すること
適切にカプセル化されたモジュールを変更すればよいかを特定しやすくする

カプセル化はｍ関係するデータやそのデータを扱う処理をまとめて、1つのモジュールとして定義すること
 */

// 【２】
/*
従業員の情報を表すEmployeeクラスがある
正しくカプセル化されるようにクラスを修正したい。修正内容として、正しいもの2つ選択
 */
public class Employee {
  String corporateName;
  String corporateAddress;
  int employeeNO;
  String name;
}
/*
・ すべてのフィールドのアクセス修飾子をprivateにする
・ フィールドにアクセスするためのgetterメソッドとsetterメソッドを追加する
・ corporateNameとcorporateAddressフィールドをほかのクラスに移動する   // 〇
・ 名前を名乗ってあいさつするメソッドを追加する   // 〇
・ 給与計算メソッドを追加する

カプセル化の実現方法に関する問題
カプセル化は、関係するデータとそのデータを使う処理をひとまとめにし、ソフトウェアの
変更容易性や再利用性を向上させるための設計原則

カプセル化を実現する方法は次の通り
1.関係するデータをまとめる
2.まとめたデータを必要とする処理をまとめる

設問のEmployeeクラスはメソッドを持たないため、「関係したデータ」をまとめただけの状態
このクラスの名前は「従業員」を表しており、従業員に関する情報だけがまとまっていなければいけない
しかし、Employeeクラスには、corporateAddressやcorporateAddressといった「会社」に関する情報も
混ざっている。これらの情報は従業員クラスから分離し、会社を表す別のクラスに移動すべきである
前述のカプセル化の実現方法にのっとると、次はデータを必要とする処理をまとめる
つまりEmployeeクラスであれば、noとnameを使うメソッドをこのクラスに割り当てる
「名前を名乗って挨拶する」メソッドは、Employeeクラスに割り当てなければならない

カプセル化は、データ隠蔽と組み合わせて完成する
データ隠蔽では、フィールドのアクセス制御を行う
よって、アクセス修飾子をprivateにすることはデータ隠蔽のために必要な手段
データ隠蔽によって、フィールドのアクセス制御が可能になり、ほかのクラスからは直接アクセスできなくなる
そこで、フィールドにアクセスするためのgetterやsetterと呼ばれるメソッドを作ることがある
これらのメソッドは、データ隠蔽に伴って必要とされるものであり、カプセル化とは関係ない
*/

// 【３】
/*
カプセル化維持に欠かせない原則1つ選択
・ データ隠蔽 // 〇
・ 情報隠蔽
・ 抽象化
・ データ抽象

データ隠蔽の概念に関する問題
データ隠蔽の目的は、カプセル化の維持
カプセル化は開発や保守のコストを削減するための設計原則の1つ
この原則が崩れると、コストが余計にかかる可能性が高くなる

カプセル化を崩す原因は、あるモジュールのデータにほかのモジュールからアクセスすること
カプセル化では、関係するデータとそのデータを必要とする処理を集める
そのため、モジュールAにあるデータを必要とする処理はすべてAになければならない
しかし、あるデータを必要とする処理がほかのモジュールに存在すると、そのデータに変更が加わった場合の
影響をすべてのモジュールで調べる必要が生じる
このような事態に陥らないために、データを隠蔽し、アクセスを拒否することで、カプセル化を維持する

 */

// 【６】
/*
共通部分だけを抽出し、それ以外を無視して扱うことを何と呼ぶ？1つ選択
・ 抽象化 // 〇
・ カプセル化
・ データ隠蔽
・ 情報隠蔽

抽象化の概念に関する問題
抽象化は、対象から注目すべき要素を抜き出し、それ以外を無視することによって、複雑な問題を
単純化する方法
単純化すれば、全t内臓をつかみやすくなったり、問題の本質をとらえやすくなったりする効果がある
なお、オブジェクト指向では、抽象化してオブジェクトを扱うことを「ポリモーフィズム」と呼ぶ

抽象化のおかげで、モジュールの数が増えたとしても、シンプルに表現できるようになる
これをソフトウェア開発に導入すれば、複雑化しすぎるソフトウェア構造を単純化し、ソフトウェア開発の
生産性を上げ、パグを減らし、コストを削減できるようになる
 */

// 【８】
// 次のプログラムをコンパイル、実行したときの結果として正しいもの1つ選択
public class Parent {
  public void method() {
    System.out.println("Parent");
  }
}
public class Child extends Parent {
  public void method(String val) {  // シグニチャが異なるためオーバーライドではなくオーバーロードしている
    System.out.println(val);
  }
}
public class Main {
  public static void main(String[] args) {
    Parent P = new Child();
    P.method("Child");  // 親クラスには存在しない、オーバーロードされたmethodメソッドを実行しようとしている
  }
}
/*
・ 「Parent」と表示される
・ 「Child」と表示される
・ Childクラスの2行目でコンパイルエラーが発生する
・ Mainクラスの3行目でコンパイルエラーが発生する
・ Mainクラスの4行目でコンパイルエラーが発生する
・ 実行時に例外がスローされる


コードにおける抽象化の表現に関する問題
抽象化は共通部分だけに着目し、その他の部分を無視することで、複雑な構造を単純化する技法
ポリモーフィズムは、継承やインタフェースの実装によって抽象化を実現する

設問のコードは、Parentクラスを継承したChildクラスを定義している
注意するところは、ParentとChildで定義しているmethodメソッドのシグニチャが異なる点
つまり、Childのmethodメソッドは、オーバーライドではなくオーバーロードしている
そのため、ChildクラスのStringを引数に受け取るmethodメソッドは、Parentには存在しないメソッド

コンパイルエラーが発生する
 */


// 【９】
/*
ポリモーフィズムのメリットに関する説明1つ選択
・ 変更されたクラスのサブクラスに変更の影響が及ばない
・ 変更されたクラスのスーパークラスに変更の影響が及ばない
・ 変更されたクラスを使うクラスに、変更の影響が及ばないない // 〇
・ インタフェースの変更が実装クラスに及ばない

ポリモーフィズムの特徴に関する問題
様々な種類のインスタンスを抽象化し、共通の型で扱う

・ どの型で扱っていたとしても、実際に動作するのはインスタンスそのものである
・ 「使う側」のクラスは、「共通化して扱える型」だけを知っていればよく、「使われる側」
    の具体的な違いを意識することはない
・ 「使う側」が「使われる側」の変更の影響を受けるとはない
・ 影響を受けるのは、共通化して扱える型が変わったときのみ

ポリモーフィズムは、使う側と使われる側が直接関係しないようにすることで、
変更時の影響範囲を居所化

サブクラスはスーパークラスの特性を引き継ぐため、サブクラス側でオーバーライドしない限り、
スーパークラスの変更は、それを継承したサブクラスに直接影響を及ぼす
同様にインタフェースの変更は、クラスが従うべき使用の変更を意味するため、それを実装したクラスに影響を及ぼす
 */

// 【１０】
/*
情報隠蔽の説明として正しいもの1つ選択
・ 公開すべきものと非公開にすべきものを区別して扱う // 〇

・ 関係するデータをひとまとめにして扱える // カプセル化の説明

・ 外部からフィールドを直接操作できないようにすることができる // データ隠蔽の説明

・ 異なる引数を受け取る同名メソッドを複数定義できる // オーバーロードの説明

情報隠蔽の概念に関する問題
情報隠蔽は、抽象化の効果を維持するために必要な設計原則

モジュールの独自機能が使われるのを避けるために、公開すべきものと非公開にすべきものを分け、
非公開に菅着物を隠蔽するよう設計をしなければならない
公開すべきところは、抽象化によって着目した共通部分
一方、非公開にすべきところは公開部分の反対、すなわち共通部分以外のすべて

さらに、非公開にする部分はアクセス制御を行う
こうすることで、長期間かけて改変され続けるソフトウェアであっても、当初の設計が崩れにくくなる

 */

// 【１１】
/*
情報隠蔽を実現する手段として、正しいもの3つ選択
・ フィールドのアクセス修飾子をprivateにする  // X データ隠蔽に関する実装方法

・ getterやsetterなどのアクセスメソッドを提供する // X データ隠蔽に関する実装方法

・ 公開メソッドを集めたインタフェースを用意する // 〇

・ protectedで修飾したクラスを宣言する  // X クラス宣言時に指定できるアクセス修飾子は、publicかデフォルトだけ

・ パッケージ宣言を追加する // X パッケージ外からアクセスできずコンパイルエラー

・ コンストラクタをprotectedにする  // X アクセス修飾子にデフォルトやprotected,privateなども
                                     使えるため、より柔軟な制御が可能

情報隠蔽の実現方法に関する問題
公開すべきものと、非公開にすべきものを分け、非公開にすべきものを隠蔽するよう設計するという原則

Javaでは、公開部分をインタフェースとして定義する
抽象化されたモジュール群は、インタフェースを実現するよう実装し、ポリモーフィズムによって、
実際に働くインスタンスの型を隠蔽する。また、非公開部分への不適切なアクセスを防ぐために
パッケージやアクセス修飾子を使って、アクセスを制御する

情報隠蔽とは、抽象化の効果を維持するために、公開すべきものと非公開にすべきものを分け、
非公開にすべきものを隠蔽する設計原則
 */

// 【１２】
/*
インタフェースに関する説明として、誤っているものを1つ選択
・ インタフェースは型を定義するためのものである // X 実装を持たず、型だけを定義したもの

・ インタフェースには実装を定義できない   // X 実装を持たないメソッド宣言のリスト

・ インタフェースはインスタンス化できない // X 実装を持たないため、インスタンス化できない

・ インタフェースにはメソッド宣言だけが定義できる // 〇

インタフェースの概念と特徴に関する問題
情報隠蔽の実現方法として挙げたインタフェースについて問うもの

≪特徴≫
・ 実装を持たないメソッド宣言のリスト
・ 実装を持たないため、インスタンス化できない
・ 実装は、インタフェースを実現したクラスが提供する
・ メソッドの宣言以外には、定数のみ定義

Javaのプログラムは。コンパイルや実行時に「型」と「実装」に分けて扱われる
インタフェースは、この「型」を表したもの
ここでは、インタフェースを理解するために、まず「型」と「実装」が異なる概念
 */

// 【１３】
/*
ポリモーフィズムに関係が深い用語として、もっとも適切なもの2つ選択
・ 抽象化   // 〇
・ 情報隠蔽
・ データ隠蔽
・ カプセル化

抽象化、ポリモーフィズム、情報隠蔽の概念に関する問題
抽象化によって複数のモジュールをあたかも1つのモジュールであるかのように扱える
抽象化に使うのが「型」の情報
intやdoubleといったデータ型がそのデータの種類を表すように、型は種類であり、
「同じ型」であれば「同じ種類」であることを意味する

Javaでは、intやdoubleといったプリミティブ型以外にクラスやインターフェースも型として扱える
型（扱い方）と実装（動作）は異なるもの
そのため、共通のクラスを継承したり、共通のインタフェースを実現したりすることで、異なる型のインスタンス同士でも、
同じ型のインスタンスとして扱える
このように、インスタンスそのものの型ではなく、抽象化した型でインスタンスを扱うことを「ポリモーフィズム」
と呼ぶ

≪データ隠蔽≫
外部のモジュールから内部のデータを隠蔽すること
カプセル化に深く関わる設計原則であり、ポリモーフィズムと直接かかわるものではない

≪カプセル化≫
関係するデータとそのデータを使う処理をひとまとめにする
カプセル化によってまとめられたモジュールをJavaでは「クラス」と呼ぶ
カプセル化は、単体のクラスについての設計原則であり、ポリモーフィズムとは直接関係しない
*/

// 【１４】
/*
AとBの2つのクラスがある
この2つのクラスで「A has-a B」の関係を表現しているコードとして、正しいもの1つ選択
 */
public class B {
  public void sample() {
    A a = new A();
  }
}

public class A {
  public void sample() {
    B b = new B();
  }
}

public class B {
  private A a;
}

public class A {    // 〇
  private B b;
}
/*
has-a関係の意味とコードでの表現について問う問題
ソフトウェアに限らず、何らかの対象を理解するための行動を「分析」と呼ぶ
ソフトウェア開発では、顧客の要求を聞き、何を作らなければいけないかを正しく理解するために、
要求そのものや背景となる業務の分析は欠かせない
古くからある分析のための技法には、「分解」と「分類」がある
分解は構造を明らかにし、分類は共通点を体系化する
オブジェクト指向によるモデリングでは、この分解と分類という技法を取り入れ、ソフトウェアとして
表現すべき対象を理解しやすくしている

≪has-a関係≫
物事を分解して「全体と部分の関係」で表す

「持っている」ことをJavaでは、フィールドで表現する

 */

// 【１５】
// インタフェースやクラスがあるとき、is-a関係を正しく表しているものを2つ選択
public interface A {
  // any code
}

public abstract class B implementes A {
  // any code
}

public class C extends B {
  // any code
}

public class D implements A {
  // any code
}

/*
・ A is-a B   // X 上位から下位の分類への関係
・ C is-a A   // 〇 下位から上位の分類への関係
・ B is-a A   // 〇 下位から上位の分類への関係
・ D is-a B   // X 横の分類に対しての関係
・ B is-a D   // X 横の分類に対しての関係
・ B is-a C   // X 上位から下位の分類への関係 

is-a関係の意味とコードの表現について問う問題
分類は、共通点を見つけて体系化することで、全体像を見失うことなく、個別の物事に分解する
分析の技法。分解が構造を使った文政方法であるのに対し、分類は意味や役割、本質に着目して分析する方法
オブジェクト指向では分類を汎化・特化の関係で表現し、Javaでは継承の関係で表現する
なお、インタフェースとそれを実現するクラスとの関係もis-a関係にある

is-a関係は「サブクラス is-a スーパークラス」または「実装クラス is-a インタフェース」という関係で表現
「自動車 is-a ガソリン車(自動車はガソリン車である)」のように反対にならないようにする
また、「ガソリン車 is-a 電気自動車(ガソリン車は電気自動車である)」という関係がおかしいように、
同じスーパークラスを継承したサブクラス同士もis-a関係は成り立たない
 */

// 【１６】
// プログラムをコンパイル、実行した結果として正しいもの1つ選択
public interface MusicPlayer {
  String play();
}
public class CdPlayter implements Music Player {
  public String play() {
    return "A";
  }
}
public class Mp3Player {
  public String play() {
    return "B";
  }
}
public class Main {
  public static void main(String[] args) {
    MuscPlayer[] players = { new CdPlayer(), new Mp3Player(), new CdPlayer() };
    for (MusicPlater : players) {
      System.out.print(plater.play());
    }
  }
}
/*
・ CdPlaterクラスでコンパイルエラーが発生する
・ Mp3Platerクラスでコンパイルエラーが発生する
・ Mainクラスでコンパイルエラーが発生する   // 〇
・ Mainクラスの実行中に例外がスローされる
・ 「ABC」と表示される
・ 「AB」と表示される

型の互換性についての問題
ポリモーフィズムに関する出題は、まず変数の型とインスタンスの互換性を確認するようにする
互換性を確認するためにも、UMLのクラス図を記述すると理解しやすくなる
複雑だと感じたら、積極的にUMLを利用するようにしよう

ポリモーフィズムに関する問題では、まず編巣の型とインスタンスの互換性を確認すること！
UMLのクラス図を記述すると理解しやすくなる
 */